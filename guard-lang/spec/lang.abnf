/* An Guard Language file defines a set of rules that can enforced for policy */
file            = *(
                     comment  /
                     let-expr /
                     rule-expr
                   )

/* Let expression provides assignments to named variables. Let expression can
 * provide either assignment to query or a value. It also provides an OR assignment
 * that allows on to first evaluated the left hand side expression and if that fails
 * assigns right hand side expression
 */
let-expr        = OCS* let 1*OCS var-name 1*OCS assign *OCS
                  ( let-query | value ) [1*OCS or-operator 1*OCS (let-query | value)]

/* "let" keyword for assignment statements */
let             = %x108.101.116         ; let

/* Let query form is a bit different from regular select/filter form in the sense that
 * no variable captures are allowed
 */
let-query       = let-query-segment [ *OCS decimal-dot *OCS *let-query-segment ]

let-query-segment   = property-name [ *OCS open-braces *OCS let-filter-expr *OCS close-braces ]

/* Property names are ASCII or quoted string with any character. For UTF-8 string
 * please use string-literal version
 */
property-name       = var-name /
                      string-literal /
                      var-reference

/* Assignment filter expressions does have variable captures allowed.
 * It allows for lookup by key on map/structs, lookup by index on collection
 * or just filter by clauses
 */
let-filter-expr     = var-reference     /           ; variable reference like %names
                      integer-literal   /           ; array index
                      string-literal    /           ; map lookup
                      1*block-expr                  ; filtering

var-reference       = percentage var-name

/* Key character references */
assign              = %x61                      ; =

percentage          = %x37                      ; %

open-braces         = %x91                      ; [

close-braces        = %x93                      ; ]

open-brackets       = %x123                     ; {

close-brackets      = %x125                     ; }

open-parenthesis    = %x40                      ; (

close-parenthesis   = %41                       ; )

vertical-bar        = %x124                     ; |

decimal-dot         = %x46                      ; .

not                 = %x110.111.116             ; not

/* Primary Language Expressions */

/* Block expression contains one or more assignment expressions along with
 * and conjunction using those assignments. Any block expression must contain
 * atleast one and-conjunction.
 * Assignment and conjunctions statements can be interleaved
 */
block-expr          = *OCS ( *(let-expr / and-conjunction) / and-conjunction ) *OCS


/* Conjunctive Normal form related rules */

/* AND conjunctions is and of disjunction clauses. It has an optional negation
 * clause at the start of the expression
 */
and-conjunction     = [NOT] conjunction-expr
conjunction-expr    = disjunction-expr *(AND disjunction-expr)
disjunction-expr    = expr [OR expr]

inline-and          = %x97.110.100 1*OCS  /     ; and
                      %x65.78.68 1*OCS    /     ; AND
                      %x38.38                   ; &&

implicit-and        = CR           /            ; \r
                      LF                        ; \n

AND                 = inline-and / implicit-and

OR                  = 1*OCS %x79.82 1*OCS      /  ; OR
                      1*OCS %x111.114 1*OCS    /  ; or
                      2*vertical-bar            ; ||

NOT                 = not 1*OCS     /           ; not<1*space/comment>
                      %x33                      ; !

expr                = group-expr    /
                      unary-expr    /
                      binary-expr   /
                      rule-expr

group-expr          = *OCS open-parenthesis *OCS and-conjunction *OCS close-parenthesis

unary-expr          = prefix-unary-expr / suffix-unary-expr

binary-expr         = [prefix-unary-operator 1*OCS] query-or-value *OCS binary-operator *OCS query-or-value

rule-expr           = var-name [*OCS open-parenthesis *OCS 1*parameters *OCS
                                ((value-separator *OCS close-parenthesis) / close-parenthesis)]


value-separator     =" %x44                     ; ,

parameters          = parameter *(*OCS value-separator *OCS parameter)

parameter           = query-or-value [OR query-or-value]

/* Unary operation related expressions
 */
prefix-unary-expr   = prefix-unary-operation 1*OCS query [ *OCS message-doc ]
suffix-unary-expr   = query 1*OCS suffix-unary-operator [ *OCS message-doc ]

/* Boolean unary expressions
 */
suffix-unary-operator  =  [NOT] exists          /
                          [NOT] empty           /
                          [NOT] is-string       /
                          [NOT] is-integer      /
                          [NOT] is-float        /
                          [NOT] is-bool         /
                          [NOT] is-map          /
                          [NOT] is-list

prefix-unary-operator   = any                   /   ; zero or more match
                          anyone                /   ;
                          atleast-one           /   ; one or more match
                          some                  /   ;
                          keys                  /   ; keys Gfor map
                          indices                   ; indices for a collection

any                     = "any" / "ANY"
anyone                  = "anyone" / "ANYONE"
atleast-one             = "atleast-one" / "ATLEAST-ONE"
some                    = "some"

/* Function based unary operations, they functions return a
 * list of values from the RHS
 */
keys                    = "keys" / "KEYS"
indices                 = "indices" / "INDICES"

is-string           = "IS-STRING"   /   "is-string"
is-integer          = "IS-INTEGER"  /   "is-integer"
is-float            = "IS-FLOAT"    /   "is-float"
is-bool             = "IS-BOOL"     /   "is-bool"
is-map              = "IS-MAP"      /   "is-map"
is-list             = "IS-LIST"     /   "is-list"

/* Binary operation related expressions
 */
binary-operator     = equals                / ;
                      not-equals            /
                      greater               / ;
                      greater-than-equals   / ;
                      lesser                / ;
                      lesser-than-equals    / ;
                      in                    / ;
                      AND                   / ;
                      OR

equals              = "=="
not-equals          = "!="
greater             = ">"
greater-than-equals = ">="
lesser              = "<"
lesser-than-equals  = "<="
in                  = *OCS ("in" / "IN") 1*OCS

binary-expr         = query-or-value binary-operator query-or-value

query-or-value      = *OCS (query / value) *OCS

/* Query */
query               = query-segment [ *OCS decimal-dot *OCS query-segment ]
query-segment       = property-name [ *OCS open-braces *OCS query-filter-segment *OCS close-braces ]

query-filter-segment    = let-filter-expr   /
                          var-name          /                               ; variable capture
                          [var-name *OCS vertical-bar *OCS] 1*block-expr    ;


/* Variable name
 *
 * all of the start with alphabet and can have any number of alpha numeric or "-" following
 * them
 */
var-name        = ALPHA *(ALPHA / DIGIT / "-" )

/* This should be fixed to UTF-8 */
alpha-numeric   = [0-9A-Za-z]
alpha           = [a-zA-Z]

OCS             = 1*(comment|multispace)

/* Comments start with # until end of line is encountered. */
comment         = pound (any-char - end-of-line)* end-of-line
pound           = %x35              ; #

/* The entire UTF-8 character range */
any-char        = [\\u{0}-\\u{10FFFF}]

/* mapping for a end of line character that maps \r\n, \n or EOF */
end-of-line     = CR / LF / EOF

/* space or end-of-line */
multispace      = ( space | end-of-line )

space           = "\u0020"

/*
 * value can be scalar, an array or map type. Value can contain literals or query types
 */
value           = ( scalar | array | map )

/* Literals that are supported */
scalar          = string-literal    /
                  integer-literal   /
                  float-literal     /
                  bool-literal      /
                  regex-literal

/* String literals
 *
 * All strings are enclosed inside '"' or "'". The quotes can be escaped
 */
string-literal      = single-quote (escape-single|any-char)* single-quote /
                      double-quote (escape-double|any-char)* double-quote

single-quote                = "'"

double-quote                = "\""

escape-single               = "\\" single-quote

escape-double               = "\\" double-quote

/* Regex literals
 */
regex-literal           = forward-slash *(escape-forward-slash|any-char) forward-slash

forward-slash           = %x47              ; /

escape-forward-slash    = "\\" forward-slash

/* integer literal
 */
sign                    = ("+" / "-")

integer-literal         = [sign] 1*DIGIT1 1*OCS

/* float literal
 */
float-literal           = [sign] ( decimal-dot 1*DIGIT                      /
                                   1*DIGIT decimal-dot *(DIGIT)             /
                                   1*DIGIT ( "e" / "E" ) [sign] 1*DIGIT )

bool-literal            = true /
                          false

true                    = "true" / "TRUE"

false                   = "false" / "FALSE"

/* Array or collection, there is no special provision for sets here
 */
array                   = *OCS open-braces *OCS
                               (1*array-values *OCS
                               ((value-separator *OCS close-braces) / close-braces)) /
                               close-braces

array-values            = array-value *(*OCS value-separator *OCS array-value)

array-value             = let-query / value

map                     = *OCS open-brackets
                              (1*key-values *OCS
                               ((map-value-separator *OCS close-brackets) / close-brakets)) /
                              close-brackets

key-values              = key-value *(map-value-separator key-value)

key-value               = key-type *OCS map-value-separator *OCS map-value

key-type                = var-name / string-literal

map-value               = array-value